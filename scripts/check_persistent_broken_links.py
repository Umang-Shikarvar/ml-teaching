#!/usr/bin/env python3
"""
Script to check for broken links that would persist even after GitHub Actions build.
This focuses on validating links that can't be fixed by the build process itself.
"""
import os
import re
import sys
from pathlib import Path

def extract_links(content):
    """Extract all links from markdown content"""
    # Pattern to match markdown links [text](url)
    pattern = r'\[([^\]]+)\]\(([^)]+)\)'
    links = re.findall(pattern, content)
    return [(text.strip(), url.strip()) for text, url in links]

def is_github_actions_generated_link(url):
    """Check if a link is to a resource that GitHub Actions will generate"""
    # HTML files in notebooks directory are generated by GitHub Actions
    if url.startswith('notebooks/') and url.endswith('.html'):
        return True
    
    # Any other patterns for generated content?
    return False

def check_link(link, base_path):
    """Check if a link is valid"""
    url = link[1]
    
    # Skip external links
    if url.startswith('http'):
        return True, "External link"
    
    # Skip links that GitHub Actions will generate
    if is_github_actions_generated_link(url):
        return True, "Generated by GitHub Actions"
    
    # Handle relative paths
    if url.startswith('.'):
        full_path = (base_path.parent / url).resolve()
    else:
        full_path = (base_path.parent / url).resolve()
    
    # Check if file exists
    if full_path.exists():
        return True, f"File exists: {full_path.relative_to(Path.cwd())}"
    else:
        return False, f"File not found: {full_path.relative_to(Path.cwd())}"

def check_pdf_references():
    """Check for PDF references in LaTeX files using \includepdf"""
    print("\nüîç Checking PDF references in LaTeX files...")
    
    # Find all .tex files
    tex_files = list(Path('.').rglob('*.tex'))
    
    missing_pdfs = []
    found_pdfs = []
    
    for tex_file in tex_files:
        try:
            with open(tex_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Find \includepdf commands
            pattern = r'\\includepdf(?:\[[^\]]*\])?\s*\{([^}]+)\}'
            matches = re.findall(pattern, content)
            
            for match in matches:
                pdf_path = match.strip()
                # Skip LaTeX variables
                if '\\' in pdf_path:
                    continue
                
                # Try to resolve the path
                pdf_dir = tex_file.parent
                possible_paths = [
                    pdf_dir / pdf_path,
                    Path(pdf_path),
                ]
                
                # Add .pdf extension if needed
                if not pdf_path.endswith('.pdf'):
                    for base_path in possible_paths.copy():
                        possible_paths.append(base_path.with_suffix('.pdf'))
                
                # Check if any path exists
                pdf_exists = False
                actual_path = None
                for path in possible_paths:
                    if path.exists() and path.is_file():
                        pdf_exists = True
                        actual_path = str(path)
                        break
                
                if pdf_exists:
                    found_pdfs.append({
                        'tex_file': str(tex_file),
                        'pdf_path': pdf_path,
                        'actual_path': actual_path
                    })
                else:
                    missing_pdfs.append({
                        'tex_file': str(tex_file),
                        'pdf_path': pdf_path,
                        'searched_paths': [str(p) for p in possible_paths]
                    })
        except Exception as e:
            print(f"Warning: Could not read {tex_file}: {e}")
    
    if missing_pdfs:
        print(f"‚ùå Found {len(missing_pdfs)} missing PDF references:")
        for missing in missing_pdfs:
            print(f"   üìÑ {missing['pdf_path']} referenced in {missing['tex_file']}")
        return False
    else:
        print(f"‚úÖ All PDF references are valid ({len(found_pdfs)} found)")
        return True

def check_qmd_links():
    """Check for broken links in QMD files that won't be fixed by GitHub Actions"""
    # Get all QMD files
    project_root = Path('.')
    qmd_files = list(project_root.glob('*.qmd'))
    
    # Also check slides and tutorials directories
    for dir_name in ['slides', 'tutorials']:
        qmd_files.extend(project_root.glob(f'{dir_name}/*.qmd'))
    
    broken_links = []
    valid_links = []
    
    print("üîç Checking QMD files for broken links...")
    
    for qmd_file in qmd_files:
        print(f"   Checking {qmd_file.name}...")
        try:
            content = qmd_file.read_text()
            links = extract_links(content)
            
            for link in links:
                is_valid, message = check_link(link, qmd_file)
                if not is_valid:
                    broken_links.append((qmd_file.name, link[0], link[1], message))
                else:
                    valid_links.append((qmd_file.name, link[0], link[1], message))
        except Exception as e:
            print(f"   Warning: Could not read {qmd_file}: {e}")
    
    # Report results
    print(f"\nüìä QMD Link Validation Results:")
    print(f"   ‚úÖ Valid links: {len(valid_links)}")
    print(f"   ‚ùå Broken links: {len(broken_links)}")
    
    if broken_links:
        print(f"\n‚ùå Broken links that won't be fixed by GitHub Actions:")
        by_file = {}
        for file, text, url, message in broken_links:
            if file not in by_file:
                by_file[file] = []
            by_file[file].append((text, url, message))
            
        for file, links in by_file.items():
            print(f"   {file}:")
            for text, url, message in links:
                print(f"     - [{text}]({url}) - {message}")
        return False
    else:
        print("üéâ All QMD links are valid!")
        return True

def main():
    """Main validation function"""
    print("üîç Validating links that persist after GitHub Actions build...")
    
    # Check QMD links
    qmd_valid = check_qmd_links()
    
    # Check PDF references
    pdf_valid = check_pdf_references()
    
    # Overall result
    if qmd_valid and pdf_valid:
        print(f"\nüéâ All links and references are valid!")
        return 0
    else:
        print(f"\n‚ùå Some links or references are broken!")
        return 1

if __name__ == "__main__":
    sys.exit(main())